import numpy as np
import matplotlib.pyplot as plt

from fym.core import BaseEnv, BaseSystem
from fym.utils.rot import dcm2quat, quat2dcm, angle2quat, quat2angle
import fym.logging
from fym.agents import LQR


class Mixer:
    """Definition:
        Mixer takes force commands and translate them to actuator commands.
        Actuator commands here mean the force generated by each rotor.
    """
    def __init__(self, rtype, d, c):
        b = 1

        if rtype == "quad":
            B = np.array(
                [[1, 1, 1, 1],
                 [0, -d, 0, d],
                 [d, 0, -d, 0],
                 [-c, c, -c, c]]
            )

        elif rtype == "hexa-x":
            B = np.array(
                [[b, b, b, b, b, b],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [c, -c, c, -c, -c, c]]
            )

        elif rtype == "hexa-+":
            B = np.array(
                [[b, b, b, b, b, b],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [c, -c, c, -c, -c, c]]
            )

        else:
            B = np.eye(4)

        self.B = B
        self.Binv = np.linalg.pinv(B)

    def inverse(self, rotors):
        return self.B.dot(rotors)

    def __call__(self, forces):
        return self.Binv.dot(forces)


class Multicopter(BaseEnv):
    """Reference:
        Prof. Taeyoung Lee's model for quadrotor UAV is used.
        - (https://www.math.ucsd.edu/~mleok/pdf/LeLeMc2010_quadrotor.pdf)
    """
    J = np.diag([0.0820, 0.0845, 0.1377])  # kg * m^2
    Jinv = np.linalg.inv(J)
    m = 4.34  # kg
    d = 0.0315  # m
    b = 1
    c = 8.004e-4  # m
    g = 9.81  # m/s^2
    rotor_max = 100
    rotor_min = 0

    def __init__(self,
                 pos=np.zeros((3, 1)),
                 vel=np.zeros((3, 1)),
                 quat=np.vstack((1, 0, 0, 0)),
                 omega=np.zeros((3, 1)),
                 ref=np.vstack([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]),
                 rtype="hexa-x"):
        super().__init__(dt=0.001, max_t=10)
        self.pos = BaseSystem(pos)
        self.vel = BaseSystem(vel)
        self.quat = BaseSystem(quat)
        self.omega = BaseSystem(omega)

        angle_ref = np.array([quat2angle(ref[6:10])]).reshape((3, 1))
        self.ref = np.vstack((ref[0:6], angle_ref, ref[10::]))

        self.u = np.zeros((4, 1))

        self.mixer = Mixer(rtype, d=self.d, c=self.c)

        A = np.array([[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, self.g, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, self.g, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
        B = np.array([[0, 0, 0, 0],
                      [0, 0, 0, 0],
                      [0, 0, 0, 0],
                      [0, 0, 0, 0],
                      [0, 0, 0, 0],
                      [-1/self.m, 0, 0, 0],
                      [0, 0, 0, 0],
                      [0, 0, 0, 0],
                      [0, 0, 0, 0],
                      [0, self.Jinv[0, 0], 0, 0],
                      [0, 0, self.Jinv[1, 1], 0],
                      [0, 0, 0, self.Jinv[2, 2]]])
        C = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
                      [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]])
        Q = np.diag([5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0])
        R = np.diag([1, 1, 1, 1])
        self.K, *_ = LQR.clqr(A, B, Q, R)

    def deriv(self, pos, vel, quat, omega):
        M = np.vstack((self.M1, self.M2, self.M3))

        m, g, J = self.m, self.g, self.J
        e3 = np.vstack((0, 0, 1))

        dpos = vel
        dcm = quat2dcm(quat)
        dvel = g*e3 - self.F*dcm.dot(e3)/m
        dquat = 0.5 * np.vstack((
            -omega.T.dot(quat[1:]),
            omega*quat[0] - np.cross(omega, quat[1:], axis=0)
        ))
        domeg = self.Jinv.dot(M - np.cross(omega, J.dot(omega), axis=0))

        return dpos, dvel, dquat, domeg

    def set_dot(self, t):
        states = self.observe_list()
        dots = self.deriv(*states)
        self.pos.dot, self.vel.dot, self.quat.dot, self.omega.dot = dots

    def step(self):
        t = self.clock.get()
        states = self.observe_dict()
        pos = self.pos.state
        vel = self.vel.state
        quat = self.quat.state
        angle = np.array([np.flip(quat2angle(quat))]).reshape((3, 1))
        omega = self.omega.state

        x = np.vstack((pos, vel, angle, omega)) - self.ref
        self.u = -self.K.dot(x) + np.vstack([self.m*self.g, 0, 0, 0])
        self.F, self.M1, self.M2, self.M3 = self.u

        rotors = self.mixer(self.u)

        *_, done = self.update()
        return t, states, rotors, done


def run(pos, quat, ref):
    system = Multicopter(pos=pos, quat=quat, ref=ref)
    system.reset()
    logger = fym.logging.Logger(path='data.h5')

    while True:
        system.render()
        t, states, rotors, done = system.step()
        logger.record(t=t, **states, rotors=rotors)

        if done:
            break

    system.close()
    logger.close()


def plot_var():
    data = fym.logging.load('data.h5')
    fig = plt.figure()

    ax1 = fig.add_subplot(4, 1, 1)
    ax2 = fig.add_subplot(4, 1, 2, sharex=ax1)
    ax3 = fig.add_subplot(4, 1, 3, sharex=ax1)
    ax4 = fig.add_subplot(4, 1, 4, sharex=ax1)

    ax1.plot(data['t'], data['pos'].squeeze())
    ax2.plot(data['t'], data['vel'].squeeze())
    ax3.plot(data['t'], data['quat'].squeeze())
    ax4.plot(data['t'], data['omega'].squeeze())

    ax1.set_ylabel('Position')
    ax1.legend([r'$x$', r'$y$', r'$z$'])
    ax1.grid(True)

    ax2.set_ylabel('Velocity')
    ax2.legend([r'$u$', r'$v$', r'$w$'])
    ax2.grid(True)

    ax3.set_ylabel('Quaternion')
    ax3.legend([r'$q_0$', r'$q_1$', r'$q_2$', r'$q_3$'])
    ax3.grid(True)

    ax4.set_ylabel('Angular Velocity')
    ax4.legend([r'$p$', r'$q$', r'$r$'])
    ax4.set_xlabel('Time [sec]')
    ax4.grid(True)

    plt.tight_layout()

    fig2 = plt.figure()
    ax1 = fig2.add_subplot(6, 1, 1)
    ax2 = fig2.add_subplot(6, 1, 2, sharex=ax1)
    ax3 = fig2.add_subplot(6, 1, 3, sharex=ax1)
    ax4 = fig2.add_subplot(6, 1, 4, sharex=ax1)
    ax5 = fig2.add_subplot(6, 1, 5, sharex=ax1)
    ax6 = fig2.add_subplot(6, 1, 6, sharex=ax1)

    ax1.plot(data['t'], data['rotors'].squeeze()[:, 0])
    ax2.plot(data['t'], data['rotors'].squeeze()[:, 1])
    ax3.plot(data['t'], data['rotors'].squeeze()[:, 2])
    ax4.plot(data['t'], data['rotors'].squeeze()[:, 3])
    ax5.plot(data['t'], data['rotors'].squeeze()[:, 4])
    ax6.plot(data['t'], data['rotors'].squeeze()[:, 5])

    ax1.set_ylabel('rotor1')
    ax1.grid(True)
    ax2.set_ylabel('rotor2')
    ax2.grid(True)
    ax3.set_ylabel('rotor3')
    ax3.grid(True)
    ax4.set_ylabel('rotor4')
    ax4.grid(True)
    ax5.set_ylabel('rotor5')
    ax5.grid(True)
    ax6.set_ylabel('rotor6')
    ax6.grid(True)
    ax6.set_xlabel('Time [sec]')

    plt.tight_layout()


# input값 조절 가능
if __name__ == "__main__":
    # ref
    x = 0
    y = 0
    z = 50
    ref = np.vstack([x, y, -z, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0])
    # perturbation
    pos_pertb = np.vstack([0, 0, 0])
    yaw = 10
    pitch = 0
    roll = 0
    quat_pertb = np.array([angle2quat(np.deg2rad(yaw, pitch, roll))]).reshape((4, 1))
    run(pos=pos_pertb, quat=quat_pertb, ref=ref)
    plot_var()
    plt.show()
