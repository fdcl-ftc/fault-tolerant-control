import numpy as np

from fym.core import BaseEnv, BaseSystem
from fym.utils.rot import dcm2quat, quat2dcm, angle2quat, quat2angle


class Mixer:
    """Definition:
        Mixer takes force commands and translate them to actuator commands.
        Actuator commands here mean the force generated by each rotor.
    """
    def __init__(self, rtype, d, c, b):
        if rtype == "quad":
            B = np.array(
                [[1, 1, 1, 1],
                 [0, -d, 0, d],
                 [d, 0, -d, 0],
                 [-c, c, -c, c]]
            )

        elif rtype == "hexa-x":
            b = 1
            B = np.array(
                [[b, b, b, b, b, b],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [c, -c, c, -c, -c, c]]
            )

        elif rtype == "hexa-+":
            b = 1
            B = np.array(
                [[b, b, b, b, b, b],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [c, -c, c, -c, -c, c]]
            )
        elif rtype == "hexa-falconi":
            B = np.array(
                [[b, b, b, b, b, b],
                 [0.5*d*b, d*b, 0.5*d*b, -0.5*d*b, -d*b, -0.5*d*b],
                 [0.5*np.sqrt(3)*d*b, 0, -0.5*np.sqrt(3)*d*b, -0.5*np.sqrt(3)*d*b, 0, 0.5*np.sqrt(3)*d*b],
                 [c, -c, c, -c, c, -c]]
            )

            self.b_gyro = np.vstack((1, -1, 1, -1, 1, -1))

            s2 = 1/2
            s3 = np.sqrt(3)/2
            self.d_rotor = np.array([
                [d, 0, 0],
                [d*s2, -d*s3, 0],
                [-d*s2, -d*s3, 0],
                [-d, 0, 0],
                [-d*s2, d*s3, 0],
                [d*s2, d*s3, 0],
            ])

        else:
            B = np.eye(4)

        self.b = b
        self.B = B
        self.Binv = np.linalg.pinv(B)

    def inverse(self, rotors):
        return self.B.dot(rotors)

    def __call__(self, forces):
        return self.Binv.dot(forces)


class Multicopter(BaseEnv):
    model = "taeyoung_lee"
    if model == "taeyoung_lee":
        """Reference:
            Prof. Taeyoung Lee's model for quadrotor UAV is used.
            - (https://www.math.ucsd.edu/~mleok/pdf/LeLeMc2010_quadrotor.pdf)
            Variables:
                pos: position in I-coord.
                vel: velocity in I-coord.
                rot: from I- to B-coord.
                quat: unit quaternion, corresponding to the rotation matrix from I- to B-coord.
        """
        J = np.diag([0.0820, 0.0845, 0.1377])  # kg * m^2
        Jinv = np.linalg.inv(J)
        m = 4.34  # kg
        d = 0.0315  # m
        c = 8.004e-4  # m
        b = 1
        g = 9.81  # m/s^2
        rotor_max = 100
        rotor_min = 0
    elif model == "falconi":
        """Reference
        - Hexacopter information
        [1] V. S. Akkinapalli, G. P. Falconí, and F. Holzapfel,
        “Attitude control of a multicopter using L1 augmented quaternion based backstepping,”
        Proceeding - ICARES 2014 2014 IEEE Int. Conf. Aerosp. Electron. Remote Sens. Technol.,
        no. November, pp. 170–178, 2014.
        [2] M. C. Achtelik, K. M. Doth, D. Gurdan, and J. Stumpf,
        “Design of a multi rotor MAV with regard to efficiency, dynamics and redundancy,”
        AIAA Guid. Navig. Control Conf. 2012, no. August, pp. 1–17, 2012.
        """
        J = np.diag([0.010007, 0.0102335, 0.0081])  # kg * m^2
        Jinv = np.linalg.inv(J)
        m = 0.64  # kg
        d = 0.215  # m
        c = 1.2864e-7  # m
        b = 6.546e-6
        g = 9.81  # m/s^2
        rotor_min = 0
        rotor_max = (2*m*g/b)/6  # TODO

    # Parameters from Baldini et al., 2020
    kr = 1e-3 * np.eye(3)  # Rotational friction coefficient (avg.) [N*s*m/rad]
    Jr = 6e-5  # Rotor inertia [N*m]
    rho = 1.225  # Air density [kg/m^3]
    CdA = 0.08  # Flat plate area [m^2]
    R = 0.15  # Rotor radius [m]
    ch = 0.04  # Propeller chord [m]
    a0 = 6  # Slope of the lift curve per radian [-]

    # Parameters from P. Pounds et al., 2010
    sigma = 0.054  # Solidity ratio [-]
    thetat = np.deg2rad(4.4)  # Blade tip angle [rad]
    CT = 0.0047  # Thrust coefficient [-]

    def __init__(self,
                 pos=np.zeros((3, 1)),
                 vel=np.zeros((3, 1)),
                 dcm=np.eye(3),
                 quat=np.vstack((1, 0, 0, 0)),
                 omega=np.zeros((3, 1)),
                 rtype="hexa-x"):
        super().__init__()
        self.pos = BaseSystem(pos)
        self.vel = BaseSystem(vel)
        self.dcm = BaseSystem(dcm)
        self.quat = BaseSystem(quat)
        self.omega = BaseSystem(omega)

        self.mixer = Mixer(rtype, d=self.d, c=self.c, b=self.b)

    # def deriv(self, pos, vel, quat, omega, rotors):
    def skew(self, x):
        x = x.ravel()
        return np.array([[0, -x[2], x[1]],
                         [x[2], 0, -x[0]],
                         [-x[1], x[0], 0]])

    def deriv(self, pos, vel, dcm, quat, omega, rotors):
        F, M1, M2, M3 = self.mixer.inverse(rotors)

        M = np.vstack((M1, M2, M3))

        m, g, J = self.m, self.g, self.J
        e3 = np.vstack((0, 0, 1))

        dpos = vel
        # dcm = quat2dcm(quat)
        dvel = g*e3 - F*dcm.T.dot(e3)/m
        breakpoint()
        ddcm = -self.skew(omega)@dcm
        _w = np.ravel(omega)
        # dquat = 0.5 * np.vstack((
        #     -omega.T.dot(quat[1:]),
        #     omega*quat[0] - np.cross(omega, quat[1:], axis=0)
        # ))
        dquat = 0.5 * np.array([[0., -_w[0], -_w[1], -_w[2]],
                                [_w[0], 0., _w[2], -_w[1]],
                                [_w[1], -_w[2], 0., _w[0]],
                                [_w[2], _w[1], -_w[0], 0.]]).dot(quat)
        eps = 1 - (quat[0]**2+quat[1]**2+quat[2]**2+quat[3]**2)
        k = 1
        dquat = dquat + k*eps*quat
        domeg = self.Jinv.dot(M - np.cross(omega, J.dot(omega), axis=0))

        return dpos, dvel, ddcm, dquat, domeg

    def set_dot(self, t, rotors):
        states = self.observe_list()
        dots = self.deriv(*states, rotors)
        self.pos.dot, self.vel.dot, self.dcm.dot, self.quat.dot, self.omega.dot = dots

    def get_Omega(self, f):
        f = np.clip(f, 0, self.rotor_max)
        Omega = self.mixer.b_gyro.T.dot(np.sqrt(f / self.mixer.b))
        return Omega

    def get_FM_wind(self, f, vel, omega, windvel):
        relvel = windvel - vel

        f = np.clip(f, 0, self.rotor_max)

        # Frame drag
        F_drag = 1/2 * self.rho * self.CdA * np.linalg.norm(relvel) * relvel

        # Blade Flapping
        F_blade = np.zeros((3, 1))
        M_blade = np.zeros((3, 1))
        for fi, di in zip(f, self.mixer.d_rotor):
            di = di[:, None]
            if fi != 0:
                Omegai = np.sqrt(fi / self.mixer.b)
                vr = relvel + np.cross(omega, di, axis=0)
                mur = np.linalg.norm(vr[:2]) / (Omegai * self.R)
                psir = np.arctan2(vr[1, 0], vr[0, 0])
                lambdah = np.sqrt(self.CT / 2)
                gamma = self.rho * self.a0 * self.ch * self.R**4 / self.Jr
                v1s = 1 / (1 + mur**2 / 2) * 4 / 3 * (
                    self.CT / self.sigma * 2 / 3 * mur * gamma / self.a0 + mur)
                u1s = 1 / (1 - mur**2 / 2) * mur * (
                    4 * self.thetat - 2 * lambdah**2)
                alpha1s, beta1s = np.array([
                    [np.cos(psir), -np.sin(psir)],
                    [np.sin(psir), np.cos(psir)]
                ]).dot(np.vstack((u1s, v1s)))

                ab = np.vstack((
                    -np.sin(alpha1s),
                    -np.cos(alpha1s) * np.sin(beta1s),
                    np.cos(alpha1s) * np.cos(beta1s) - 1))

                F_blade += self.mixer.b * Omegai**2 * ab
                M_blade += np.cross(di, self.mixer.b * Omegai**2 * ab, axis=0)

        F_wind = F_blade + F_drag
        M_wind = M_blade

        return F_wind, M_wind


if __name__ == "__main__":
    system = Multicopter()
    system.set_dot(t=0, rotors=np.zeros((6, 1)))
    print(repr(system))
