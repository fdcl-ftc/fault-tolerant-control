import numpy as np

from fym.core import BaseEnv, BaseSystem
from fym.utils.rot import dcm2quat, quat2dcm, angle2quat, quat2angle
   


class Mixer:
    """Definition:
        Mixer takes force commands and translate them to actuator commands.
        Actuator commands here mean the force generated by each rotor.
    """
    def __init__(self, rtype, d, c, b):
        if rtype == "quad":
            B = np.array(
                [[1, 1, 1, 1],
                 [0, -d, 0, d],
                 [d, 0, -d, 0],
                 [-c, c, -c, c]]
            )

        elif rtype == "hexa-x":
            b = 1
            B = np.array(
                [[b, b, b, b, b, b],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [c, -c, c, -c, -c, c]]
            )

        elif rtype == "hexa-+":
            b = 1
            B = np.array(
                [[b, b, b, b, b, b],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [c, -c, c, -c, -c, c]]
            )
        elif rtype == "hexa-":
            B = np.array(
                [[b, b, b, b, b, b],
                 [0.5*d*b, d*b, 0.5*d*b, -0.5*d*b, -d*b, -0.5*d*b],
                 [0.5*np.sqrt(3)*d*b, 0, -0.5*np.sqrt(3)*d*b, -0.5*np.sqrt(3)*d*b, 0, 0.5*np.sqrt(3)*d*b],
                 [c, -c, c, -c, c, -c]]
            )

        else:
            B = np.eye(4)

        self.B = B
        self.Binv = np.linalg.pinv(B)

    def inverse(self, rotors):
        return self.B.dot(rotors)

    def __call__(self, forces):
        return self.Binv.dot(forces)


class Multicopter(BaseEnv):
    # """Reference:
    #     Prof. Taeyoung Lee's model for quadrotor UAV is used.
    #     - (https://www.math.ucsd.edu/~mleok/pdf/LeLeMc2010_quadrotor.pdf)
    #     Variables:
    #         pos: position in I-coord.
    #         vel: velocity in I-coord.
    #         quat: unit quaternion, corresponding to the rotation matrix from I- to B-coord.
    # """
    J = np.diag([0.0820, 0.0845, 0.1377])  # kg * m^2
    Jinv = np.linalg.inv(J)
    m = 4.34  # kg
    d = 0.0315  # m
    c = 8.004e-4  # m
    b = 1
    g = 9.81  # m/s^2
    rotor_max = 100
    rotor_min = 0
    # J = np.diag([0.010007, 0.0102335, 0.0081])  # kg * m^2
    # Jinv = np.linalg.inv(J)
    # m = 0.64  # kg
    # d = 0.215  # m
    # c = 1.2864e-7  # m
    # b = 6.546e-6
    # g = 9.81  # m/s^2
    # rotor_min = 0
    # rotor_max = (2*m*g/b)/6  # TODO

    def __init__(self,
                 pos=np.zeros((3, 1)),
                 vel=np.zeros((3, 1)),
                 quat=np.vstack((1, 0, 0, 0)),
                 # dcm=np.eye(3),
                 omega=np.zeros((3, 1)),
                 rtype="hexa-x"):
        super().__init__()
        self.pos = BaseSystem(pos)
        self.vel = BaseSystem(vel)
        self.quat = BaseSystem(quat)
        # self.dcm = BaseSystem(dcm)
        self.omega = BaseSystem(omega)

        self.mixer = Mixer(rtype, d=self.d, c=self.c, b=self.b)

    # def deriv(self, pos, vel, quat, omega, rotors):
    def skew(self, x):
        x = x.ravel()
        return np.array([[0, -x[2], x[1]],
                         [x[2], 0, -x[0]],
                         [-x[1], x[0], 0]])

    # def deriv(self, pos, vel, dcm, omega, rotors):
    def deriv(self, pos, vel, quat, omega, rotors):
        F, M1, M2, M3 = self.mixer.inverse(rotors)

        M = np.vstack((M1, M2, M3))

        m, g, J = self.m, self.g, self.J
        e3 = np.vstack((0, 0, 1))

        dpos = vel
        dcm = quat2dcm(quat)
        dvel = g*e3 - F*dcm.dot(e3)/m
        # ddcm = self.skew(omega)*dcm
        dquat = 0.5 * np.vstack((
            -omega.T.dot(quat[1:]),
            omega*quat[0] - np.cross(omega, quat[1:], axis=0)
        ))
        domeg = self.Jinv.dot(M - np.cross(omega, J.dot(omega), axis=0))

        return dpos, dvel, dquat, domeg
        # return dpos, dvel, ddcm, domeg

    def set_dot(self, t, rotors):
        states = self.observe_list()
        dots = self.deriv(*states, rotors)
        self.pos.dot, self.vel.dot, self.quat.dot, self.omega.dot = dots
        # self.pos.dot, self.vel.dot, self.dcm.dot, self.omega.dot = dots


if __name__ == "__main__":
    system = Multicopter()
    system.set_dot(t=0, rotors=np.zeros((6, 1)))
    print(repr(system))
